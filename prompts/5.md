# Prompt 5: Error Handling & Edge Cases

**Priority:** P1
**Focus:** Full-stack Robustness
**Skill Required:** None

---

## Pre-Flight Checklist

1. **Read all issues:** Check every `docs/issues/*/README.md` file
2. **Review existing error handling:**
   ```bash
   grep -rn "catch\|error\|Error" mobile/hooks/ | head -30
   grep -rn "abort_code\|assert!" contracts/sources/ | head -30
   ```

---

## Context

The app needs comprehensive error handling for production readiness:
- Network failures
- Wallet connection issues
- Transaction failures
- Invalid user input
- Contract errors

---

## Requirements

### 1. Mobile: Error Boundaries

Create `mobile/components/shared/ErrorBoundary.tsx`:

```typescript
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} onRetry={...} />;
    }
    return this.props.children;
  }
}
```

Wrap main app sections with error boundaries.

### 2. Mobile: Toast Notifications

Create `mobile/components/shared/Toast.tsx` and `mobile/hooks/useToast.ts`:

```typescript
// useToast.ts
export function useToast() {
  return {
    showSuccess: (message: string) => { ... },
    showError: (message: string) => { ... },
    showWarning: (message: string) => { ... },
  };
}
```

Use toasts for:
- Bet placed successfully
- Bet failed (with reason)
- Winnings claimed
- Network errors
- Wallet errors

### 3. Mobile: Hook Error States

Audit all hooks in `mobile/hooks/` and ensure they:
- Return `error` state
- Handle loading states
- Provide retry functions
- Log errors for debugging

Example pattern:
```typescript
export function useMarkets() {
  const { data, error, isLoading, refetch } = useQuery({
    queryKey: ['markets'],
    queryFn: fetchMarkets,
    retry: 3,
    retryDelay: (attempt) => Math.min(1000 * 2 ** attempt, 30000),
  });

  return {
    markets: data ?? [],
    isLoading,
    error: error?.message,
    refetch,
  };
}
```

### 4. Mobile: Empty States

Create empty state components for:
- No markets available
- No positions (My Bets empty)
- No winnings to claim
- Network offline

### 5. Contract: Error Codes

Verify all contract modules have descriptive error codes:

```move
const E_MARKET_NOT_FOUND: u64 = 1;
const E_MARKET_ALREADY_SETTLED: u64 = 2;
const E_INSUFFICIENT_BALANCE: u64 = 3;
const E_BET_TOO_SMALL: u64 = 4;
const E_BET_TOO_LARGE: u64 = 5;
const E_UNAUTHORIZED: u64 = 6;
// ... etc
```

Create a mapping file: `mobile/constants/contractErrors.ts`:
```typescript
export const CONTRACT_ERRORS: Record<number, string> = {
  1: 'Market not found',
  2: 'Market already settled',
  3: 'Insufficient balance for this bet',
  4: 'Bet amount too small (min $0.10)',
  5: 'Bet amount too large (max $10)',
  6: 'Unauthorized action',
};

export function parseContractError(code: number): string {
  return CONTRACT_ERRORS[code] ?? `Unknown error (code: ${code})`;
}
```

### 6. Backend: Error Responses

Ensure all API endpoints return consistent error format:

```json
{
  "success": false,
  "error": {
    "code": "INSUFFICIENT_BALANCE",
    "message": "Not enough MOVE tokens for this bet",
    "details": { "required": 1000000, "available": 500000 }
  }
}
```

### 7. Edge Cases to Handle

| Scenario | Expected Behavior |
|----------|------------------|
| Wallet disconnects mid-transaction | Show error, allow retry |
| Network timeout | Retry 3x, then show offline message |
| Double-tap bet button | Disable during transaction |
| Market resolves during bet | Show "Market closed" error |
| User has 0 balance | Show "Deposit needed" prompt |
| Contract paused | Show maintenance message |
| Invalid market ID in deep link | Show "Market not found" |

---

## Implementation Steps

1. **Audit existing hooks** - List all error cases
2. **Create ErrorBoundary** - Top-level error catch
3. **Create Toast system** - User feedback
4. **Update hooks** - Add error/loading/retry
5. **Create empty states** - For all list screens
6. **Create error mapping** - Contract codes → messages
7. **Update API responses** - Consistent format
8. **Test each edge case** - One by one

---

## Verification

```bash
# Check error handling coverage
grep -rn "catch\|\.error\|isError" mobile/hooks/
grep -rn "showError\|showToast" mobile/components/
```

Manual testing:
- [ ] Turn off network → App shows offline state
- [ ] Force API error → Toast appears
- [ ] Empty markets → Empty state shows
- [ ] Empty positions → Empty state shows
- [ ] Contract error → User-friendly message shows
- [ ] Wallet disconnect → Graceful handling

---

## Do NOT

- Swallow errors silently (always log or show)
- Show raw error messages to users
- Crash on recoverable errors
- Add complex retry logic (keep simple)

---

## Deliverables

1. `ErrorBoundary.tsx` component
2. `Toast.tsx` and `useToast.ts`
3. Updated hooks with error states
4. Empty state components
5. `contractErrors.ts` mapping
6. Consistent API error format
7. All edge cases handled gracefully

---

## Post-Completion

1. Document error patterns in `docs/issues/ui/README.md`
2. Delete this prompt file: `rm prompts/5.md`
3. Report: "completed prompt 5"
